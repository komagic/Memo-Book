# 性能优化（不要过早优化）
## 1. 衡量标准
### RAIL性能模型
RAIL是一种以用户为中心的性能模型，每个网络应用均具有与其生命周期有关的四个不同方面，且这些方面以不同的方式影响着性能：

+ 以用户为中心：应该是使得用户满意。
+ Response：在100ms以内确认用户输入。
+ Animation：设置动画或滚动时候，在10ms以内生成帧。尽量保持60fps。
+ Idle: 最大限度增加主线程的空闲时间。
+ Load：在1000ms以内呈现交互内容。

## 2. 代码优化
### 2.1 数据读取速度
数据访问有快慢：
+ 字面量与局部变量的访问速度最快，数组元素和对象成员相对较慢。
+ 变量从局部作用域到全局作用域的搜索过程越长速度越慢
+ 对象嵌套越深，读取速度就更慢
+ 对象在原型链中存在的位置越深，找到它的的速度就越慢

> 方案：是缓存对象成员值。将对象成员值缓存到局部变量中会加快访问速度

### 2.2 DOM
操作DOM的代价非常高昂：
> 1. 在js中对DOM进行访问的代价非常高。请尽可能减少访问DOM的次数。
> 2. 重排与重绘的代价非常高昂。如果需要操作进行多次重排与重绘，建议先让元素脱离文档流，处理后再让元素回归文档流，这样浏览器只会进行两次重排与重绘（脱离与回归的时候）。
> 3. 善于使用事件委托。

### 2.3 流程控制
流程控制，大型项目可以采用：
+ 避免使用for… in
+ 在JS中倒序循环会略微提升性能
+ 减少迭代的次数
+ 基于循环的迭代比基于函数的迭代快8倍
+ 用Map表代替大量的if-else和switch会提升性能

## 3. 静态资源优化
Web应用的运行离不开静态资源，所以对静态资源的优化至关重要。
### 3.1 使用brotli或zopfli进行纯文本压缩
在最高级别的压缩下brotli会非常慢以至于服务器在等待的时间会抵消掉高压缩率的好处，它非常适合静态文件压缩，解压速度快。

### 3.2 图片优化
尽可能通过srcset，sizes和picture元素使用响应式图片。还可以通过picture元素使用webP格式的图像。
模糊图片中不重要的部分，使用html5视频替换gif图，因为视频比GIF文件小

## 4.交付优化
交付优化指对页面加载资源以及用户与网页之间的交付过程进行优化。

### 4.1异步无阻塞加载JS
JS的加载与执行会阻塞页面渲染，可以将Script标签放到页面的最底部。但是更好的做法是异步无阻塞加载JS。有多种无阻塞加载JS的方法：defer、async、动态创建script标签、使用XHR异步请求JS代码并注入到页面。
推荐defer、async。使用defer或async请将script标签放到head标签中，以便让浏览器更早地发现资源并在后台线程中解析并开始加载JS。

### 4.2 使用Intersection Observer实现懒加载
懒加载时一个比较常用的性能优化手段，下面列出一些常用的做法：
+ 可以通过Intersection Observer延迟加载图片、视频、广告脚本、或任何其他资源。
+ 可以先加载低质量或模糊的图片。当图片加载完毕后再使用完整版图片替换它。

> 延迟加载所有体积较大的组件、字体、JS、视频或Iframe是一个好主意

### 4.3 优先加载关键css到header中

### 4.4 资源提示 （Resource Hints）
资源提示定义了HTML中的Link元素与dns-prefetch、preconnect、prefetch、prerender

4.4.1 dns-prefetch
提示浏览器尽早解析

4.4.2 preconnect
用于启动预链接，其中包含dns查找，TCP握手，以及可选的TLS协议，允许浏览器减少建立连接的开销。

4.4.3 prefetch
Prefetch用于标识下一个导航可能需要的资源。浏览器会获取该资源，一旦将来请求该资源，浏览器可以提供更快的响应。

4.4.4 prerender
用于标识下个导航可能需要的资源。浏览器会获取并执行，一旦将来请求该资源，浏览器可以提供更快的响应。

### 4.5 Preload
通过一个现有元素声明资源会将获取与执行耦合在一起。然而应用可能只是想要先获取资源，当满足某些条件时再执行资源。

### 4.6 快速响应的用户界面

## 5. 构建优化
现代前端应用都需要有构建过程。如构建后的文件体积、代码执行效率、文件加载时间、首次有效绘制指标等。

### 5.1 使用预编译
拿Vue举例，如果您使用单文件组件开发项目，组件会在编译剪短将模板便以为渲染函数。最终代码被执行时可以直接执行渲染函数进行渲染。而如果您没有使用单文件组件预编译代码，而是在网页中引入vue.min.js,那么应用在运行时需要先将模板编译成渲染函数，然后再执行渲染函数进行渲染。相比预编译，多了模板编译的步骤，所以会浪费很多性能。

### 5.2 使用Tree-shaking、Scope hoisting、Code-spliting
Tree-shaking是一种在构建过程中清楚无用代码的技术。使用Tree-shaking可以减少构建后文件的体积。

目前webpack都支持Scope Hoisting。他们可以检查import链，并尽可能的将散乱的木块放到一个函数中，前提是不能造成代码冗余。所以只有被引用了一次的木块才会被合并。使用Scope Hoisting可以让代码体积更小并且可以降低代码在运行时的内存开销，同事他的运行速度更快。前面2.1节介绍了变量从局部作用域到全局作用域的搜搜过程越长执行速度越慢，Scope Hoisting可以减少搜索时间。

Code-splitting是Webpack中最引人注目的特性之一。此特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。

5.3服务端渲染（Server Side Sender）
单页面应用需要等待js加载问题后在前端渲染页面，也就是说在Js加载完毕并开始执行渲染操作钱的这段时间里浏览器会产生白屏。
