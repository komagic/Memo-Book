# 深入 React 架构
在《框架使用》中，你已经了解了如何使用 React 及与之相关的一些概念，比如 JSX、生命周期方法等，但这些更偏向 React 的使用。如果你想继续了解 React 的工作原理，不妨继续读下本文。
### Virtual DOM
即使没有用过 React，恐怕你也已经听过或在其他框架中接触了 VDOM 这个名词。正如其名，VDOM 即「虚拟的 DOM」。在讲述何为 VDOM 之前，不妨先来复习一下何为 DOM：
文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。
引自 MDN
### 什么是 VDOM
DOM 是浏览器内置的特性，用来描述页面的结构、样式和内容。当然，你也已经知道在使用 DOM 的时候有很多需要注意的问题。而 VDOM 即是对真正的 DOM 的模拟，它与 DOM 一样，同样能够描述页面的结构、样式和内容。不过， VDOM 往往以 Javascript 对象的形式存储和操作，而不是浏览器提供的接口。
下面即是一个 VDOM 节点可能的结构：

```
{
    type: 'div',
    props: {
        className: 'foo'
    },
    style: {
        width: 300,
        height: 200
    },
    children: []
}
```

这是一个最简单的 VDOM 节点，它描述了页面中的某个元素：div 标签，类名为 foo，高宽，子节点……有了这些信息，渲染器（Renderer）就能够渲染出一个真实的页面。

当然，React 中的 VDOM 要比这复杂得多，不仅有上述的基本信息，还包含用于优化性能的节点标识和各种对象引用，在数据结构上还常常与组件内部的生命周期方法混合在一起（如果你感兴趣可以尝试对 react-dom 中的一些关键函数断点，就能看到他们）。
需要强调的是，VDOM 与真实 DOM 并不是一一对应关系，一些 VDOM 节点可能找不到其对应的 DOM 节点，而只表示一层「虚」的层级逻辑。其实很好理解，在写 React 组件的时候，实际上是在写 VDOM ，其中的标签并不止是 HTML 中真实存在的 div、p、a 等，也会有我们封装出的其他组件标签，如果每个标签都有其对应的 VDOM 节点，那么这些组件也会有。在组件层级上，他们被分类为复合组件（Composite Component）与 DOM 组件（DOM Component）；在渲染器内部，他们也会被分别处理。当然，Composite Component 展开到最后也会是 DOM Component，不过这已经脱离了本文的讨论范围，属于渲染器（Renderer）的工作过程。

### 为什么要有 VDOM
你可能已经了解了 VDOM 是什么，但因此出现了「为什么要用 VDOM？」的疑问。
首先，VDOM 本身并不能提高性能，但在 React 中 VDOM 能提高性能。
一些教程中总是提到 VDOM 能够提高性能，这其实有误导性的，VDOM 只是对页面的一种描述，如何渲染是渲染器（Renderer） 的事情。即使用了 VDOM，若渲染器在将 VDOM 更新到真实 DOM 时没有采用那些常规的优化措施，性能一样会一塌糊涂。更何况在性能上，任何框架都比不上无框架。
在 React 中，页面以组件树的形式创建和更新，这意味着在渲染器中页面是一个节点一个节点更新的，若不使用 VDOM，每个节点更新皆可能触发一次页面重排，性能自然不出所料地惨不忍睹。而使用了 VDOM 后，每个节点的 DOM 更新可不立即生效，而只暂存到一个缓存中，达到一定条件后再批处理，这令 React 具有较好的性能（当然还是远远比不过使用优化的情况下直接操作 DOM）。
其次，VDOM 使 React 脱离了浏览器的束缚，为服务端渲染和 React-Native 提供了可能。
这个比较好理解，如果 React 强依赖于浏览器提供的 API，服务端渲染就会变得更加复杂，React-Native 就只能通过模拟一套 DOM 接口来实现了。如果你需要，甚至可以将其绑定到其他任意的东西上，比如用于矢量绘图[1]或更多好玩的事情[2]。不过，这也是需要对应的渲染器来配合的。ReactDOM 即是我们将 React 用于 Web 开发时使用的渲染器，React-Native 仓库中则包含了另一个渲染器来渲染到原生控件。如果你对此感兴趣或想要开发自己的基于 React 的渲染器，不妨看看前面提到的 ReactART，它会是一个非常好的学习 React 渲染器工作方式的样本，代码也很短。

### Virtual DOM 中的 diff 算法
每当 Virtual DOM 树发生更新时，我们总是希望能找到最少的转换步骤来更新真实的 DOM 树。而标准的 diff 算法[3]的时间复杂度为 O(n³)，n 为树中元素个数，这显然达不到我们期望的性能要求。在 React 中，通过以下两个假设，实现了时间复杂度为 O(n)的算法：
不同类型的两个元素将会产生不同的树。
开发人员可以使用一个 key 值来指示在不同的渲染中那个那些元素可以保持稳定。
它具体的执行过程可以分为：
对 Virtual DOM 树进行逐层遍历，比较相同父节点下的所有子节点，若子节点不存在，则完全删除该节点和其下的子节点。如图所示，每层相同颜色的节点会进行逐层、逐节点比较，当 E 节点转移到节点 C 下时，会删除原节点 E，并在 C 下新建 E 节点。

遇到 Component 时，若为相同的 Component，则进行步骤 1，若不同，则替换整个 Component。其中可以使用 shouldComponentUpdate 来辅助快速对比。如图所示，若 Component C 变换为 Component H 时，Component C、F、G 会全部被删除，并重新生成 Component H、F、G。因此，在封装组件时，若 C 和 H 结构相似，尽量应该封装为同一组件，避免节点出现新建、删除操作，降低效率。

对于同一父节点、同一层级的 Element 进行逐个比较，若为原来不存在的 Element，则进行新建和插入操作，若对比为相同类型 Element，则只需更新复用，若不为同类型，则进行删除替换，若不存在于新的 Element 集合中，则直接删除该 Element。其中，为了避免大量新建和删除操作，可以对 Element 设置 key 值，那么在遍历时，通过判断是否有相同 key 值的旧 Element，并通过位移来达到复用。
如第一张图，Element B、C 虽然没有改变，但位置发生变化，因此需要进行删除和新建节点，Element D 不存在于新的 Element 集合中，因此删除，Element E 为新的Element，因此进行新建。

如果设置了key值，那么当 Element B 和 Element C 进行变换时，只进行平移的操作，而不再进行删除和新建，效率得到提升。

以上结果，可以快速得出需要更新的 DOM 节点，虽然达不到最佳更新，但具有较强的普适性。
从 React 的 diff 算法，我们可以得出开发 React 时的一些优化策略：
减少DOM数的层级，减少跨层级的移动 DOM 操作
尽量使用 Class Component，并使用 shouldComponentUpdate 辅助 Virtual DOM 快速判断是否为相同的组件。若 props 中有函数，提前进行 bind this。
对于列表或相同类型的组件，使用 key 优化。

### setState 与视图更新
setState 方法用于改变当前组件的状态。若不考虑 shouldComponentUpdate 返回 false 的情况，每当 setState 方法执行后，该组件及其全部子组件的 render 方法将被递归调用以生成新的 VDOM 树。新树与旧树进行上述的 diff 运算，得到页面内容的差量更新信息，这些信息最终被用于创建、更新或销毁对应的真实 DOM。
递归生成 VDOM 是一个代价较高的操作，思考以下三种场景：
某个组件的事件处理函数、componentWillReceiveProps 等多处包含了 setState 调用，故一次用户操作可能连续触发多次 setState。
某父组件触发 setState 后，因各个子组件的生命周期内也包含 setState 操作，实际上是在极短时间内多次执行了 setState 并重复调用了子子组件的 render 方法。
高频的动画中有极短间隔的不断被执行的 setState 操作。
这些场景将极大地影响 React 的性能，轻则占用过高的 CPU 并降低电池使用时间，重则造成页面的卡顿，影响用户体验。不幸的是，上述几种场景几乎是必然会出现的。自然，React 也对其做了相应的优化。

### 事务（Transaction）in React 15
先来分析第一种场景。所有的 setState 操作其实都是由一次用户操作导致的，其终状态是确定的，每个中间状态于我们而言都是不重要的，那么我们可以等到所有的 setState 执行完后再开始调用 render 来生成 VDOM，以令性能开销最小。

（事件触发后，事件处理函数或一些生命周期函数中的 setState 调用会被合并）
这就是 React 的事务（transaction）。在 React 15 中， 执行生命周期函数或事件处理函数时会默认创建一个事务，在其内部同步调用的 setState 都将被缓存入栈，待同步函数执行结束后开始批量更新（batch update），多个 setState 会被 merge 并得到终状态，之后真正的组件更新才会开始。值得一提的是，在事务之外执行的多个 setState 是不会被合并的，比如在 setTimeout 中调用的 setState。
Fiber
对于后面两种场景，React 16 以前是没有很好的解决办法的，所以你常常会看到有人抱怨 React 的动画性能问题或指出在较高的节点上执行 setState 的性能问题，以及强调 shouldComponentUpdate 对页面帧数优化的重要性。这是因为在 React 16 以前，父节点与子节点的更新是一次性递归执行到底的，层级过深自然会增加耗时，若超过了 16ms，帧数也就下降了。
在 React 16 之后，这两类问题被名为 Fiber 的新调度算法解决，它也取代了事务成为第一类问题的新解决方案。在 Fiber 算法中，子节点不再一定跟随父节点同步更新，其更新会根据优先级同步或异步执行，若超时甚至可能被抛弃。这使得层级较多的组件更新分散在了多帧中，因而保证了帧数。


自然，这也带来了新的问题，异步更新会让组件刷新的视觉效果与之前有细微的不同，异步化和超时的设定（包括正常、重试和抛弃三种情况）会让原本确定的生命周期执行顺序和次数变得不确定，很多依赖生命周期可靠性的实现会受到影响，在高耗时操作较多时低优先级操作甚至可能永远没有机会执行……不过，绝大多数情况下我们并不需要担忧，极端的情况永远是少数，反思为什么有如此多的高耗时操作阻碍内容刷新比质疑 Fiber 算法更具有实际意义。
总体来看，Fiber Renderer 比原有的 Stack Renderer 更具有优势。Fiber 的思路更像是系统的进程调度算法或大型 3D 游戏的渲染管线，而 Web 前端场景正毫无疑问地向后者靠拢。